#pragma once

#include "BasicBlock.h"
#include <set>
#include <unordered_map>
#include <map>
#include "ExpressionNode.h"
#include "InsertableBasicBlock.h"  // full definition
#include <vector>
#include <memory>
#include "BaseNode.h"



// a static class for common functionality for dataflow analyses
class AnalysisTools {

    public:

        // constructor 
        AnalysisTools() = delete;

        //returns a vector of all the basic blocks in the flowgraph
        //uses BFS to get the basic blocks roughly in flowgraph order, starting from the entry basic block
        static std::vector<std::shared_ptr<BasicBlock>> getBasicBlocks(std::shared_ptr<BasicBlock> entryBasicBlock);

        //returns a vector of all the IR nodes in the flowgraph in the order they appear
        static std::vector<std::shared_ptr<BaseNode>> getIRNodesInFlowgraphOrder(const std::vector<std::shared_ptr<BasicBlock>>& basicBlocks);

        //returns the universe of all expressions in the program
        static std::set<std::string> getAllProgramExpressions(std::shared_ptr<BaseNode> entryNode);

        //returns the set of all expressions in a program, and also a corresponding example node for each expression (so you can convert from expression->node type)
        static std::unordered_map<std::string, std::shared_ptr<ExpressionNode>> getAllProgramExpressionsToCloneableNodesMap(std::shared_ptr<BaseNode> entryNode);

        //returns the set of all expression with their IR datatypes (take the original destination datatype of the expression)
        //pass in the irDatatypeMap of the variables in the program
        static std::unordered_map<std::string, std::string> getAllProgramExpressionsToIRDatatypeMap(std::shared_ptr<BaseNode> entryNode, std::unordered_map<std::string, std::string> irDatatypeMap);

        //returns the set of expressions Ex that are killed by the node (specific to a program)
        static std::set<std::string> getKilledExpressionsAtNode(std::shared_ptr<BaseNode> node, std::set<std::string> &allExpressions);

        //returns the set of definitions in a program
        //definitions in a program is a dictionary of {var: [list of definition points (i.e. nodes)]}, since a variable can have multiple definitions at different nodes
        // static std::unordered_map<std::string, std::set<BaseNode*>> getAllProgramDefinitionPoints(BaseNode* entryNode);

        // returns the set of ACTUAL STRING definitions at a node
        // either the generated expressions for an ExpressionNode, or the src for a MovNode
        static std::set<std::string> getDefinitionsAtNode(std::shared_ptr<BaseNode> node);

        // returns the set of all copy statements (i.e. from MovNodes) in a program
        // copy statements are a tuple of (src, dst)
        static std::set<std::pair<std::string, std::string>> getAllProgramCopyStatements(std::shared_ptr<BaseNode> entryNode);

        // returns the set of all copy statements (i.e. from MovNodes) killed by a node (which defines a variable, e.g. including ExpressionNodes)
        static std::set<std::pair<std::string, std::string>> getKilledCopyStatementsAtNode(std::shared_ptr<BaseNode> node, std::set<std::pair<std::string, std::string>> &allCopyStatements);

        // returns the set of all copy statements (i.e. from MovNodes) generated by a (Mov) node
        static std::set<std::pair<std::string, std::string>> getGeneratedCopyStatementsAtNode(std::shared_ptr<BaseNode> node);

        // returns the set of all generated expressions at a node (those expressions which are used/referenced and NOT immediately killed defined)
        static std::set<std::string> getGeneratedExpressionsAtNode(std::shared_ptr<BaseNode> node);

        // returns the set of all earliest expressions in a flowgraph
        // calculate the earliest expressions for all nodes in the flowgraph using VBE and AVAIL
        ///NOTE: could overload this with different signatures for if you have already calculated the VBE and AVAIL results
        //using weak pointer since some nodes could be removed from the flowgraph as we are later using the map
        static std::map<std::weak_ptr<BaseNode>, std::set<std::string>, std::owner_less<std::weak_ptr<BaseNode>>> getAllNodesEarliestExpressions(std::shared_ptr<BasicBlock> entryBasicBlock);

        // returns the set of all latest expressions in a flowgraph
        // Need allExpressions of the program to get the complementation
        // Need to pass in the basic blocks of the flowgraph in order to find successors of each node
        static std::map<std::weak_ptr<BaseNode>, std::set<std::string>, std::owner_less<std::weak_ptr<BaseNode>>> getAllNodesLatestExpressions(std::shared_ptr<BasicBlock> entryBasicBlock, std::set<std::string> allExpressions, std::vector<std::shared_ptr<BasicBlock>> basicBlocks);

        // returns a map of all flowgraph nodes to their corresponding basic blocks
        // in order for fast lookup of the basic block of a node
        static std::map<std::weak_ptr<BaseNode>, std::shared_ptr<BasicBlock>, std::owner_less<std::weak_ptr<BaseNode>>> getFlowgraphNodeToBasicBlockMap(std::vector<std::shared_ptr<BasicBlock>> basicBlocks);

        // returns the set of all successor nodes of a node in the flowgraph (either just 1 if SimpleNode, or get from successor basic blocks otherwise)
        static std::vector<std::weak_ptr<BaseNode>> getSuccessorNodes(std::shared_ptr<BaseNode> node, std::shared_ptr<BasicBlock> currentBasicBlock);

        //draws/redraws the flowgraph to synchronize with the updated IR tree, and returns the new entry basic block
        static std::shared_ptr<BasicBlock> drawFlowgraph(const std::shared_ptr<EntryNode>& entryNode);

        ////////////////////FACTORY METHODS to create insertion strategy for new basic blocks//////////////////

        //inserts a new instruction after a SimpleNode
        //think I can use the insertSandwichChild method in SimpleNode to do this
        static std::unique_ptr<InsertableBasicBlock::NodeInsertionStrategy> createAfterSimpleNodeInsertionStrategy(std::shared_ptr<SimpleNode> simpleNodeToInsertAfter);

        //first converts the IfNode to a new IfElseNode
        //transforming the THEN block of the IfNode into the THEN branch of the IfElseNode
        //then inserts a new instruction in the ELSE block of the IfElseNode
        static std::unique_ptr<InsertableBasicBlock::NodeInsertionStrategy> createNewElseBlockInsertionStrategy(std::shared_ptr<IfNode> ifNodeToInsertAfter);

};